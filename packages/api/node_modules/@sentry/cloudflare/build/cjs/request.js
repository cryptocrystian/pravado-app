var {
  _optionalChain
} = require('@sentry/core');

Object.defineProperty(exports, '__esModule', { value: true });

const core = require('@sentry/core');
const scopeUtils = require('./scope-utils.js');
const sdk = require('./sdk.js');

/**
 * Wraps a cloudflare request handler in Sentry instrumentation
 */
function wrapRequestHandler(
  wrapperOptions,
  handler,
) {
  return core.withIsolationScope(async isolationScope => {
    const { options, request } = wrapperOptions;

    // In certain situations, the passed context can become undefined.
    // For example, for Astro while prerendering pages at build time.
    // see: https://github.com/getsentry/sentry-javascript/issues/13217
    const context = wrapperOptions.context ;

    const client = sdk.init(options);
    isolationScope.setClient(client);

    const attributes = {
      [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.cloudflare',
      [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',
      [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.server',
      [core.SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD]: request.method,
      [core.SEMANTIC_ATTRIBUTE_URL_FULL]: request.url,
    };

    const contentLength = request.headers.get('content-length');
    if (contentLength) {
      attributes['http.request.body.size'] = parseInt(contentLength, 10);
    }

    let pathname = '';
    try {
      const url = new URL(request.url);
      pathname = url.pathname;
      attributes['server.address'] = url.hostname;
      attributes['url.scheme'] = url.protocol.replace(':', '');
    } catch (e2) {
      // skip
    }

    scopeUtils.addCloudResourceContext(isolationScope);
    if (request) {
      scopeUtils.addRequest(isolationScope, request);
      if (request.cf) {
        scopeUtils.addCultureContext(isolationScope, request.cf);
        attributes['network.protocol.name'] = request.cf.httpProtocol;
      }
    }

    const routeName = `${request.method} ${pathname ? core.stripUrlQueryAndFragment(pathname) : '/'}`;

    return core.continueTrace(
      { sentryTrace: request.headers.get('sentry-trace') || '', baggage: request.headers.get('baggage') },
      () => {
        // Note: This span will not have a duration unless I/O happens in the handler. This is
        // because of how the cloudflare workers runtime works.
        // See: https://developers.cloudflare.com/workers/runtime-apis/performance/
        return core.startSpan(
          {
            name: routeName,
            attributes,
          },
          async span => {
            try {
              const res = await handler();
              core.setHttpStatus(span, res.status);
              return res;
            } catch (e) {
              core.captureException(e, { mechanism: { handled: false, type: 'cloudflare' } });
              throw e;
            } finally {
              _optionalChain([context, 'optionalAccess', _ => _.waitUntil, 'call', _2 => _2(core.flush(2000))]);
            }
          },
        );
      },
    );
  });
}

exports.wrapRequestHandler = wrapRequestHandler;
//# sourceMappingURL=request.js.map
