Object.defineProperty(exports, '__esModule', { value: true });

const core = require('@sentry/core');
const async = require('./async.js');
const request = require('./request.js');
const scopeUtils = require('./scope-utils.js');
const sdk = require('./sdk.js');

/**
 * Extract environment generic from exported handler.
 */

/**
 * Wrapper for Cloudflare handlers.
 *
 * Initializes the SDK and wraps the handler with Sentry instrumentation.
 *
 * Automatically instruments the `fetch` method of the handler.
 *
 * @param optionsCallback Function that returns the options for the SDK initialization.
 * @param handler {ExportedHandler} The handler to wrap.
 * @returns The wrapped handler.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function withSentry(
  optionsCallback,
  handler,
) {
  async.setAsyncLocalStorageAsyncContextStrategy();

  if ('fetch' in handler && typeof handler.fetch === 'function' && !isInstrumented(handler.fetch)) {
    handler.fetch = new Proxy(handler.fetch, {
      apply(target, thisArg, args) {
        const [request$1, env, context] = args;
        const options = optionsCallback(env);
        return request.wrapRequestHandler({ options, request: request$1, context }, () => target.apply(thisArg, args));
      },
    });

    markAsInstrumented(handler.fetch);
  }

  if ('scheduled' in handler && typeof handler.scheduled === 'function' && !isInstrumented(handler.scheduled)) {
    handler.scheduled = new Proxy(handler.scheduled, {
      apply(target, thisArg, args) {
        const [event, env, context] = args;
        return core.withIsolationScope(isolationScope => {
          const options = optionsCallback(env);
          const client = sdk.init(options);
          isolationScope.setClient(client);

          scopeUtils.addCloudResourceContext(isolationScope);

          return core.startSpan(
            {
              op: 'faas.cron',
              name: `Scheduled Cron ${event.cron}`,
              attributes: {
                'faas.cron': event.cron,
                'faas.time': new Date(event.scheduledTime).toISOString(),
                'faas.trigger': 'timer',
                [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.faas.cloudflare',
                [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'task',
              },
            },
            async () => {
              try {
                return await (target.apply(thisArg, args) );
              } catch (e) {
                core.captureException(e, { mechanism: { handled: false, type: 'cloudflare' } });
                throw e;
              } finally {
                context.waitUntil(core.flush(2000));
              }
            },
          );
        });
      },
    });

    markAsInstrumented(handler.scheduled);
  }

  return handler;
}

function markAsInstrumented(handler) {
  try {
    (handler ).__SENTRY_INSTRUMENTED__ = true;
  } catch (e2) {
    // ignore errors here
  }
}

function isInstrumented(handler) {
  try {
    return (handler ).__SENTRY_INSTRUMENTED__;
  } catch (e3) {
    return false;
  }
}

exports.withSentry = withSentry;
//# sourceMappingURL=handler.js.map
