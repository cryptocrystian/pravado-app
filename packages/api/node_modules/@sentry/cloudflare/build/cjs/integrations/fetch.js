Object.defineProperty(exports, '__esModule', { value: true });

const core = require('@sentry/core');

const INTEGRATION_NAME = 'Fetch';

const HAS_CLIENT_MAP = new WeakMap();

const _fetchIntegration = ((options = {}) => {
  const breadcrumbs = options.breadcrumbs === undefined ? true : options.breadcrumbs;
  const shouldCreateSpanForRequest = options.shouldCreateSpanForRequest;

  const _createSpanUrlMap = new core.LRUMap(100);
  const _headersUrlMap = new core.LRUMap(100);

  const spans = {};

  /** Decides whether to attach trace data to the outgoing fetch request */
  function _shouldAttachTraceData(url) {
    const client = core.getClient();

    if (!client) {
      return false;
    }

    const clientOptions = client.getOptions();

    if (clientOptions.tracePropagationTargets === undefined) {
      return true;
    }

    const cachedDecision = _headersUrlMap.get(url);
    if (cachedDecision !== undefined) {
      return cachedDecision;
    }

    const decision = core.stringMatchesSomePattern(url, clientOptions.tracePropagationTargets);
    _headersUrlMap.set(url, decision);
    return decision;
  }

  /** Helper that wraps shouldCreateSpanForRequest option */
  function _shouldCreateSpan(url) {
    if (shouldCreateSpanForRequest === undefined) {
      return true;
    }

    const cachedDecision = _createSpanUrlMap.get(url);
    if (cachedDecision !== undefined) {
      return cachedDecision;
    }

    const decision = shouldCreateSpanForRequest(url);
    _createSpanUrlMap.set(url, decision);
    return decision;
  }

  return {
    name: INTEGRATION_NAME,
    setupOnce() {
      core.addFetchInstrumentationHandler(handlerData => {
        const client = core.getClient();
        if (!client || !HAS_CLIENT_MAP.get(client)) {
          return;
        }

        if (core.isSentryRequestUrl(handlerData.fetchData.url, client)) {
          return;
        }

        core.instrumentFetchRequest(handlerData, _shouldCreateSpan, _shouldAttachTraceData, spans, 'auto.http.fetch');

        if (breadcrumbs) {
          createBreadcrumb(handlerData);
        }
      }, true);
    },
    setup(client) {
      HAS_CLIENT_MAP.set(client, true);
    },
  };
}) ;

/**
 * Creates spans and attaches tracing headers to fetch requests.
 */
const fetchIntegration = core.defineIntegration(_fetchIntegration);

function createBreadcrumb(handlerData) {
  const { startTimestamp, endTimestamp } = handlerData;

  // We only capture complete fetch requests
  if (!endTimestamp) {
    return;
  }

  if (handlerData.error) {
    const data = handlerData.fetchData;
    const hint = {
      data: handlerData.error,
      input: handlerData.args,
      startTimestamp,
      endTimestamp,
    };

    core.addBreadcrumb(
      {
        category: 'fetch',
        data,
        level: 'error',
        type: 'http',
      },
      hint,
    );
  } else {
    const data = {
      ...handlerData.fetchData,
      status_code: handlerData.response && handlerData.response.status,
    };
    const hint = {
      input: handlerData.args,
      response: handlerData.response,
      startTimestamp,
      endTimestamp,
    };
    const level = core.getBreadcrumbLogLevelFromHttpStatusCode(data.status_code);

    core.addBreadcrumb(
      {
        category: 'fetch',
        data,
        type: 'http',
        level,
      },
      hint,
    );
  }
}

exports.fetchIntegration = fetchIntegration;
//# sourceMappingURL=fetch.js.map
