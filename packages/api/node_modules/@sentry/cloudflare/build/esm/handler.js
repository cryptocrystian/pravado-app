import { withIsolationScope, startSpan, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, captureException, flush } from '@sentry/core';
import { setAsyncLocalStorageAsyncContextStrategy } from './async.js';
import { wrapRequestHandler } from './request.js';
import { addCloudResourceContext } from './scope-utils.js';
import { init } from './sdk.js';

/**
 * Extract environment generic from exported handler.
 */

/**
 * Wrapper for Cloudflare handlers.
 *
 * Initializes the SDK and wraps the handler with Sentry instrumentation.
 *
 * Automatically instruments the `fetch` method of the handler.
 *
 * @param optionsCallback Function that returns the options for the SDK initialization.
 * @param handler {ExportedHandler} The handler to wrap.
 * @returns The wrapped handler.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function withSentry(
  optionsCallback,
  handler,
) {
  setAsyncLocalStorageAsyncContextStrategy();

  if ('fetch' in handler && typeof handler.fetch === 'function' && !isInstrumented(handler.fetch)) {
    handler.fetch = new Proxy(handler.fetch, {
      apply(target, thisArg, args) {
        const [request, env, context] = args;
        const options = optionsCallback(env);
        return wrapRequestHandler({ options, request, context }, () => target.apply(thisArg, args));
      },
    });

    markAsInstrumented(handler.fetch);
  }

  if ('scheduled' in handler && typeof handler.scheduled === 'function' && !isInstrumented(handler.scheduled)) {
    handler.scheduled = new Proxy(handler.scheduled, {
      apply(target, thisArg, args) {
        const [event, env, context] = args;
        return withIsolationScope(isolationScope => {
          const options = optionsCallback(env);
          const client = init(options);
          isolationScope.setClient(client);

          addCloudResourceContext(isolationScope);

          return startSpan(
            {
              op: 'faas.cron',
              name: `Scheduled Cron ${event.cron}`,
              attributes: {
                'faas.cron': event.cron,
                'faas.time': new Date(event.scheduledTime).toISOString(),
                'faas.trigger': 'timer',
                [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.faas.cloudflare',
                [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'task',
              },
            },
            async () => {
              try {
                return await (target.apply(thisArg, args) );
              } catch (e) {
                captureException(e, { mechanism: { handled: false, type: 'cloudflare' } });
                throw e;
              } finally {
                context.waitUntil(flush(2000));
              }
            },
          );
        });
      },
    });

    markAsInstrumented(handler.scheduled);
  }

  return handler;
}

function markAsInstrumented(handler) {
  try {
    (handler ).__SENTRY_INSTRUMENTED__ = true;
  } catch (e2) {
    // ignore errors here
  }
}

function isInstrumented(handler) {
  try {
    return (handler ).__SENTRY_INSTRUMENTED__;
  } catch (e3) {
    return false;
  }
}

export { withSentry };
//# sourceMappingURL=handler.js.map
